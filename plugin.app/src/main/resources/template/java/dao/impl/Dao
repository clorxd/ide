package #{$package};

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;
import com.teamide.bean.*;
import com.teamide.param.*;
import com.teamide.util.StringUtil;

import #{$IDao.$package}.#{$IDao.$classname};

public abstract class #{$classname} implements #{$IDao.$classname} {

	static Logger logger = LoggerFactory.getLogger(Dao.class);

	protected boolean showSql = true;

	@Override
	public boolean isShowSql() {
		return this.showSql;
	}

	@Override
	public void setShowSql(boolean showSql) {
		this.showSql = showSql;
	}

	@Override
	public Connection getConnection() throws SQLException {
		return getDataSource().getConnection();
	}

	@Override
	public void close(AutoCloseable... closeables) {

		if (null == closeables) {
			return;
		}
		for (AutoCloseable closeable : closeables) {
			if (null == closeable) {
				continue;
			}
			try {
				closeable.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	@Override
	public String wrapPageSql(String sql, PageSqlParam page) {
		if (StringUtil.isEmpty(sql)) {
			sql = "";
		}
		int pagesize = 10;
		int pageindex = 1;
		if (page != null) {
			pagesize = page.getPagesize();
			pageindex = page.getPageindex();
		}
		if (pagesize <= 0) {
			pagesize = 10;
		}
		if (pageindex <= 0) {
			pageindex = 1;
		}

		int start = (pageindex - 1) * pagesize;
		// int end = start + pagesize;

		sql = sql + (" LIMIT ") + (pagesize) + (" OFFSET ") + (start);
		return sql;
	}

	public boolean showSql() {
		return isShowSql();
	}

	public void log(String sql) {
		if (!showSql()) {
			return;
		}
		logger.info("sql:" + sql);
	}

	public void log(String sql, List<Object> values) {
		if (!showSql()) {
			return;
		}
		logger.info("sql:" + sql);
		logger.info("values:" + JSON.toJSONString(values));
	}

	public void batchLog(List<String> sqls) {
		if (!showSql()) {
			return;
		}
		logger.info("batch sql:" + JSON.toJSONString(sqls));
	}

	public void batchLog(String sql, List<List<Object>> valuesList) {
		if (!showSql()) {
			return;
		}
		logger.info("batch sql:" + sql);
		logger.info("batch values list:" + JSON.toJSONString(valuesList));
	}

	public void batchLog(SqlValuesList sqlValuesList) {
		if (!showSql()) {
			return;
		}
		if (sqlValuesList == null) {
			return;
		}
		for (SqlValues sqlValues : sqlValuesList) {
			logger.info("batch sql:" + sqlValues.getSql());
			logger.info("batch values:" + JSON.toJSONString(sqlValues.getValues()));
		}

	}

	public void error(String sql) {
		logger.error("error sql:" + sql);
	}

	public void error(String sql, List<Object> values) {
		logger.error("error sql:" + sql);
		logger.error("error values:" + JSON.toJSONString(values));
	}

	public void batchError(List<String> sqls) {
		logger.error("error batch sql:" + JSON.toJSONString(sqls));
	}

	public void batchError(String sql, List<List<Object>> valuesList) {
		logger.error("error batch sql:" + sql);
		logger.error("error batch values list:" + JSON.toJSONString(valuesList));
	}

	public void batchError(SqlValuesList sqlValuesList) {

		if (sqlValuesList == null) {
			return;
		}
		for (SqlValues sqlValues : sqlValuesList) {
			logger.error("error batch sql:" + sqlValues.getSql());
			logger.error("error batch values:" + JSON.toJSONString(sqlValues.getValues()));
		}
	}

	/**
	 * 查询
	 */
	@Override
	public List<Map<String, Object>> query(SqlParam sqlParam) throws SQLException {

		return query(getFactory().toSqlValues(sqlParam));

	}

	/**
	 * 查询
	 */
	@Override
	public List<Map<String, Object>> query(SqlValues sqlValues) throws SQLException {

		return query(sqlValues.getSql(), sqlValues.getValues());

	}

	/**
	 * 统计
	 */
	@Override
	public int queryCount(SqlParam sqlParam) throws SQLException {

		return queryCount(getFactory().toSqlValues(sqlParam));

	}

	/**
	 * 统计
	 */
	@Override
	public int queryCount(SqlValues sqlValues) throws SQLException {

		return queryCount(sqlValues.getSql(), sqlValues.getValues());
	}

	/**
	 * 查询列表
	 */
	@Override
	public List<Map<String, Object>> queryList(SqlParam sqlParam) throws SQLException {

		return queryList(getFactory().toSqlValues(sqlParam));
	}

	/**
	 * 查询列表
	 */
	@Override
	public List<Map<String, Object>> queryList(SqlValues sqlValues) throws SQLException {

		return query(sqlValues);
	}

	/**
	 * 查询单个
	 */
	@Override
	public Map<String, Object> queryOne(SqlParam sqlParam) throws SQLException {

		return queryOne(getFactory().toSqlValues(sqlParam));
	}

	/**
	 * 查询单个
	 */
	@Override
	public Map<String, Object> queryOne(SqlValues sqlValues) throws SQLException {

		List<Map<String, Object>> value = query(sqlValues);
		if (value == null) {
			return null;
		}
		if (value.size() > 0) {
			return value.get(0);
		} else {
			return null;
		}
	}

	/**
	 * 翻页查询
	 */
	@Override
	public PageResultBean<Map<String, Object>> queryPage(PageSqlParam pageSqlParam) throws SQLException {
		String pageSql = wrapPageSql(pageSqlParam.getSql(), pageSqlParam);

		List<Map<String, Object>> value = query(new SqlParam(pageSql, pageSqlParam.getParam()));
		int totalcount = queryCount(new SqlParam(pageSqlParam.getCountsql(), pageSqlParam.getParam()));

		PageResultBean<Map<String, Object>> result = new PageResultBean<Map<String, Object>>();
		result.setPageindex(pageSqlParam.getPageindex());
		result.setPagesize(pageSqlParam.getPagesize());
		result.setTotalcount(totalcount);
		result.setValue(value);
		return result;
	}

	@Override
	public int execute(SqlParam sqlParam) throws SQLException {
		return execute(getFactory().toSqlValues(sqlParam));
	}

	@Override
	public int execute(SqlParam sqlParam, List<Object> keyValues) throws SQLException {
		SqlValues sqlValues = getFactory().toSqlValues(sqlParam);
		return execute(sqlValues.getSql(), sqlValues.getValues(), keyValues);
	}

	@Override
	public int execute(SqlValues sqlValues) throws SQLException {

		return execute(sqlValues.getSql(), sqlValues.getValues(), null);
	}

	@Override
	public int batchExecute(SqlParamList sqlParamList) throws SQLException {

		return batchExecute(getFactory().toSqlValuesList(sqlParamList), null);
	}

	@Override
	public int batchExecute(SqlParamList sqlParamList, List<List<Object>> keyValuesList) throws SQLException {

		return batchExecute(getFactory().toSqlValuesList(sqlParamList), keyValuesList);
	}

	@Override
	public int execute(String sql) throws SQLException {
		return execute(sql, new ArrayList<Object>(), null);
	}

	public List<Map<String, Object>> query(String sql, List<Object> values) throws SQLException {

		List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();

		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			log(sql, values);
			conn = getConnection();
			ps = conn.prepareStatement(sql);
			setPreparedStatementValues(ps, values);
			rs = ps.executeQuery();
			result = toList(rs);
		} catch (SQLException e) {
			error(sql, values);
			throw e;
		} finally {
			close(rs, ps, conn);
		}
		return result;
	}

	/**
	 * 
	 * 统计
	 * 
	 * @param sql
	 *            SQL语句
	 * @param values
	 *            ?占位符对应的数据
	 * @return 统计结果
	 * @throws SQLException
	 *             SQL异常
	 */
	public int queryCount(String sql, List<Object> values) throws SQLException {

		int result = 0;
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			log(sql, values);
			conn = getConnection();
			ps = conn.prepareStatement(sql);
			setPreparedStatementValues(ps, values);
			rs = ps.executeQuery();
			while (rs.next()) {
				result = rs.getInt(1);
				break;
			}
		} catch (SQLException e) {
			error(sql, values);
			throw e;
		} finally {
			close(rs, ps, conn);
		}
		return result;
	}

	@Override
	public int batchExecute(SqlValuesList sqlValuesList) throws SQLException {

		return batchExecute(sqlValuesList, null);
	}

	@Override
	public int batchExecute(List<String> sqls) throws SQLException {

		Connection conn = null;
		try {
			conn = getConnection();
			conn.setAutoCommit(false);// 将自动提交关闭
			int res = batchExecute(conn, sqls);
			conn.commit();// 执行完后，手动提交事务
			return res;
		} catch (Exception e) {
			if (conn != null) {
				conn.rollback();
			}
			throw e;
		} finally {
			if (conn != null) {
				conn.setAutoCommit(true);// 在把自动提交打开
				close(conn);
			}
		}
	}

	protected int execute(String sql, List<Object> values, List<Object> keyValues) throws SQLException {
		Connection conn = null;
		try {
			conn = getConnection();
			conn.setAutoCommit(false);// 将自动提交关闭
			int res = execute(conn, sql, values, keyValues);
			conn.commit();// 执行完后，手动提交事务
			return res;
		} catch (Exception e) {
			if (conn != null) {
				conn.rollback();
			}
			throw e;
		} finally {
			if (conn != null) {
				conn.setAutoCommit(true);// 在把自动提交打开
				close(conn);
			}
		}
	}

	public int batchExecute(String sql, List<List<Object>> valuesList) throws SQLException {
		Connection conn = null;
		try {
			conn = getConnection();
			conn.setAutoCommit(false);// 将自动提交关闭
			int res = batchExecute(conn, sql, valuesList);
			conn.commit();// 执行完后，手动提交事务
			return res;
		} catch (Exception e) {
			if (conn != null) {
				conn.rollback();
			}
			throw e;
		} finally {
			if (conn != null) {
				conn.setAutoCommit(true);// 在把自动提交打开
				close(conn);
			}
		}
	}

	public int batchExecute(SqlValuesList sqlValuesList, List<List<Object>> keyValuesList) throws SQLException {

		Connection conn = null;
		try {
			conn = getConnection();
			conn.setAutoCommit(false);// 将自动提交关闭
			int res = batchExecute(conn, sqlValuesList, keyValuesList);
			conn.commit();
			return res;
		} catch (Exception e) {
			if (conn != null) {
				conn.rollback();
			}
			throw e;
		} finally {
			if (conn != null) {
				conn.setAutoCommit(true);// 在把自动提交打开
				close(conn);
			}
		}
	}

	public int batchExecute(Connection conn, List<String> sqls) throws SQLException {
		try {
			batchLog(sqls);
			return doBatchExecute(conn, sqls);
		} catch (Exception e) {
			batchError(sqls);
			throw e;
		}
	}

	public int execute(Connection conn, String sql, List<Object> values, List<Object> keyValues) throws SQLException {
		try {
			log(sql, values);
			return doExecute(conn, sql, values, keyValues);
		} catch (Exception e) {
			error(sql, values);
			throw e;
		}
	}

	public int batchExecute(Connection conn, String sql, List<List<Object>> valuesList) throws SQLException {
		try {
			batchLog(sql, valuesList);
			return doBatchExecute(conn, sql, valuesList);
		} catch (Exception e) {
			batchError(sql, valuesList);
			throw e;
		}
	}

	public int batchExecute(Connection conn, SqlValuesList sqlValuesList, List<List<Object>> keyValuesList)
			throws SQLException {
		try {
			batchLog(sqlValuesList);
			return doBatchExecute(conn, sqlValuesList, keyValuesList);
		} catch (Exception e) {
			batchError(sqlValuesList);
			throw e;
		}
	}

	public void setPreparedStatementValues(PreparedStatement ps, List<Object> values) throws SQLException {
		if (ps == null || values == null) {
			return;
		}
		if (values != null) {
			for (int i = 0; i < values.size(); i++) {
				Object value = values.get(i);
				int valueIndex = i + 1;
				if (null != value) {
					if (value instanceof java.util.Date) {
						// 日期特殊处理
						if (value instanceof java.sql.Date) {
							ps.setDate(valueIndex, (java.sql.Date) value);
						} else if (value instanceof java.sql.Time) {
							ps.setTime(valueIndex, (java.sql.Time) value);
						} else {
							Timestamp timestamp = new java.sql.Timestamp(((java.util.Date) value).getTime());
							ps.setTimestamp(valueIndex, timestamp);
						}
					} else if (value instanceof Number) {
						// 针对大数字类型的特殊处理
						if (value instanceof BigInteger) {
							// BigInteger转为Long
							ps.setLong(valueIndex, ((BigInteger) value).longValue());
						} else if (value instanceof BigDecimal) {
							// BigDecimal的转换交给JDBC驱动处理
							ps.setBigDecimal(valueIndex, (BigDecimal) value);
						} else {
							// 普通数字类型按照默认传入
							ps.setObject(valueIndex, value);
						}
					} else {
						ps.setObject(valueIndex, value);
					}
				} else {
					final ParameterMetaData pmd = ps.getParameterMetaData();
					int sqlType = Types.VARCHAR;
					try {
						sqlType = pmd.getParameterType(valueIndex);
					} catch (SQLException e) {
						// ignore
						// log.warn("Null param of index [{}] type get failed,
						// by:
						// {}",
						// paramIndex, e.getMessage());
					}
					ps.setNull(valueIndex, sqlType);
				}
			}
		}
	}

	public List<Map<String, Object>> toList(ResultSet rs) throws SQLException {

		List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
		ResultSetMetaData rsmd = rs.getMetaData();// 获得列集
		int columnCount = rsmd.getColumnCount();
		String columnName = null;
		while (rs.next()) {
			Map<String, Object> value = new HashMap<String, Object>();
			for (int i = 0; i < columnCount; i++) {
				int sqlIndex = i + 1;
				columnName = rsmd.getColumnLabel(sqlIndex);
				if (StringUtil.isEmpty(columnName)) {
					columnName = rsmd.getColumnName(sqlIndex);
				}
				Object v = rs.getObject(sqlIndex);
				if (v != null && v instanceof Clob) {
					Clob clob = (Clob) v;
					try {
						v = read(clob.getAsciiStream());
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
				value.put(columnName, v);
			}
			result.add(value);
		}
		return result;

	}

	public byte[] read(InputStream stream) throws IOException {

		if (null == stream) {
			return null;
		}
		ByteArrayOutputStream result = null;
		try {
			result = new ByteArrayOutputStream();
			byte[] buffer = new byte[1024];
			int length;
			while ((length = stream.read(buffer)) != -1) {
				result.write(buffer, 0, length);
			}
			return result.toByteArray();
		} finally {
			close(result, stream);
		}
	}

	public int doBatchExecute(Connection conn, List<String> sqls) throws SQLException {
		Statement statement = null;
		try {
			statement = conn.createStatement();
			for (String sql : sqls) {
				statement.addBatch(sql);
			}

			int[] res = statement.executeBatch();
			int count = 0;
			if (res != null) {
				for (int c : res) {
					count += c;
				}
			}
			return count;
		} finally {
			close(statement);
		}
	}

	public int doExecute(Connection conn, String sql, List<Object> values, List<Object> keyValues) throws SQLException {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {

			if (keyValues == null) {
				ps = conn.prepareStatement(sql);
			} else {
				ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			}
			setPreparedStatementValues(ps, values);
			int res = ps.executeUpdate();
			if (keyValues != null) {
				// 获取自增列
				rs = ps.getGeneratedKeys();

				List<Map<String, Object>> list = toList(rs);
				if (list != null && list.size() > 0) {
					Map<String, Object> one = list.get(0);
					for (Object value : one.values()) {
						keyValues.add(value);
					}
				}
			}
			return res;
		} finally {
			close(rs, ps);
		}
	}

	public int doBatchExecute(Connection conn, String sql, List<List<Object>> valuesList) throws SQLException {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement(sql);

			if (valuesList != null) {
				for (List<Object> values : valuesList) {
					setPreparedStatementValues(ps, values);
					ps.addBatch();
				}
			}
			int[] res = ps.executeBatch();

			int count = 0;
			if (res != null) {
				for (int c : res) {
					count += c;
				}
			}
			return count;
		} finally {
			close(ps);
		}
	}

	public int doBatchExecute(Connection conn, SqlValuesList sqlValuesList, List<List<Object>> keyValuesList)
			throws SQLException {

		PreparedStatement ps = null;
		ResultSet rs = null;
		int result = 0;
		try {
			if (sqlValuesList != null) {
				for (int index = 0; index < sqlValuesList.size(); index++) {
					SqlValues sqlValues = sqlValuesList.get(index);
					try {
						if (keyValuesList == null) {
							ps = conn.prepareStatement(sqlValues.getSql());
						} else {
							ps = conn.prepareStatement(sqlValues.getSql(), Statement.RETURN_GENERATED_KEYS);
						}
						setPreparedStatementValues(ps, sqlValues.getValues());
						result = result + ps.executeUpdate();

						if (keyValuesList != null) {
							// 获取自增列
							rs = ps.getGeneratedKeys();
							List<Map<String, Object>> list = toList(rs);
							List<Object> keyValues = new ArrayList<Object>();
							keyValuesList.add(keyValues);
							if (list != null && list.size() > 0) {
								Map<String, Object> one = list.get(0);
								for (Object value : one.values()) {
									keyValues.add(value);
								}
							}
						}

					} finally {
						close(rs, ps);
					}
				}
			}
		} finally {
			close(ps);
		}
		return result;
	}
}
